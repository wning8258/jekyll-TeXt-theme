---
layout: post
title: Android 属性动画解析
key: 20181125 Android 属性动画解析
tags: Android 属性动画解析 animation
---

#Android 属性动画解析（1）

Android 提供了两种动画系统：Property Animation和View Animation，属性动画更推荐使用，它更加灵活，并且有更强大的功能。另外，还有一种动画：Drawable Animation,也就是俗称的帧动画，它可以用来显示一帧帧的图片。这里主要讲一下属性动画。

##1.Property Animation介绍

属性动画从Android3.0(Api11)可以使用，它不仅仅可以设置View的属性，甚至普通的Object的属性都可以。
属性动画可以让你通过动画的方式操作以下属性：

- Duration :你可以指定动画执行的时间，默认时间为300ms
- Time interpolation:时间差值，你可以实现自己的函数还控制属性具体怎么变化。系统也提供了一些实现，比如LinearInterpolator,AccelerateInterpolator.....
- Repeat count and behavior:重复次数和模式，重复的时候是从头开始还是从尾开始。
- Animator sets：属性集，你可以定义一组动画，让他们同时执行，依次执行，还是延迟一段时间执行。
- Frame refresh delay：帧刷新延迟，你可以指定多少秒刷新一帧，默认10ms.基本用不上。

##2.Property Animation 用法

###2.1 Animator

1. ValueAnimator：看名字就知道这个类不关心view，只关心值。你只要设置了开始结束值，时间，就可以start了
```
ValueAnimator animation = ValueAnimator.ofFloat(0f, 1f);
animation.setDuration(1000);
animation.start();
```
如果你想通过ValueAnimator设置view,只能通过`addUpdateListener`在`onAnimationUpdate（）`回调里，调用animation的`getAnimatedValue（）`
设置给view.

![enter image description here](/Users/wning/work/md/pics/a2d09439jw1f9jybag1lhj20k306o0ts.jpg)

有1个很有意思的点，ValueAnimator默认肯定会有一个Interpolator，我们会想当然的认为肯定是LinearInterpolator,嘿嘿，其实并不是:
```
// The time interpolator to be used if none is set on the animation
    private static final TimeInterpolator sDefaultInterpolator =
            new AccelerateDecelerateInterpolator();
```
这里居然是AccelerateDecelerateInterpolator，真是想不到。
2. ObjectAnimator：它是ValueAnimator的子类，可以传入一个对象和它的属性，从来实现动画效果，这个类是用到最多的类。
```
ObjectAnimator anim = ObjectAnimator.ofFloat(foo, "alpha", 0f, 1f);
anim.setDuration(1000);
anim.start();
```
foo这个对象必须要有setAlpha和getAlpha方法，否则不会出现应有的效果。

3. AnimatorSet：动画集。可以传入多个ValueAnimator或ObjectAnimator，控制他们一起播放或者before after。
```
AnimatorSet bouncer = new AnimatorSet();
bouncer.play(bounceAnim).before(squashAnim1);
bouncer.play(squashAnim1).with(squashAnim2);
bouncer.play(squashAnim1).with(stretchAnim1);
bouncer.play(squashAnim1).with(stretchAnim2);
bouncer.play(bounceBackAnim).after(stretchAnim2);
ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", 1f, 0f);
fadeAnim.setDuration(250);
AnimatorSet animatorSet = new AnimatorSet();
animatorSet.play(bouncer).before(fadeAnim);
animatorSet.start();
```
###2.2 Animaton Listeners

在动画执行的过程中，你可以监听以下事件：
1. Animator.AnimatorListener
- onAnimationStart() - 动画开始
- onAnimationEnd() - 动画结束
- onAnimationRepeat() - 动画重复执行
- onAnimationCancel() -动画取消，这种情况下，onAnimationEnd()也会触发
2. ValueAnimator.AnimatorUpdateListener
  onAnimationUpdate() -动画执行的每一帧都会被调用,可以调用ValueAnimator的getAnimatedValue得到当前的值。

另外，系统提供了一个抽象类AnimatorListenerAdapter，实现了AnimatorListener的所有接口，如果你只想实现AnimatorListener的部分接口，可以new一个AnimatorListenerAdapter的实现类：
```
ValueAnimator fadeAnim = ObjectAnimator.ofFloat(newBall, "alpha", 1f, 0f);
fadeAnim.setDuration(250);
fadeAnim.addListener(new AnimatorListenerAdapter() {
public void onAnimationEnd(Animator animation) {
    balls.remove(((ObjectAnimator)animation).getTarget());
}

```
###2.3 Evaluator

Evaluator会根据传入过来的startValue,endValue,fraction，得到currentValue,返回.

Evaluator分为4种：IntEvaluator,FloatEvaluator,ArgbEvaluator,TypeEvaluator
前三种分为用来控制int，float，颜色，这三种的实现是一样的，只是类型不同而已,

startValue + fraction * (endValue - startValue)
就是一个线性的函数，这里可以注意一下ArgbEvaluator：

```
  public Object evaluate(float fraction, Object startValue, Object endValue) {
        int startInt = (Integer) startValue;
        int startA = (startInt >> 24) & 0xff;
        int startR = (startInt >> 16) & 0xff;
        int startG = (startInt >> 8) & 0xff;
        int startB = startInt & 0xff;

        int endInt = (Integer) endValue;
        int endA = (endInt >> 24) & 0xff;
        int endR = (endInt >> 16) & 0xff;
        int endG = (endInt >> 8) & 0xff;
        int endB = endInt & 0xff;

        return (int)((startA + (int)(fraction * (endA - startA))) << 24) |
                (int)((startR + (int)(fraction * (endR - startR))) << 16) |
                (int)((startG + (int)(fraction * (endG - startG))) << 8) |
                (int)((startB + (int)(fraction * (endB - startB))));
    }
```
ArgbEvaluator接收的是一个16进制的argb颜色值，比如0xFFFF8080，`evaluate`方法通过位运算把a r g b分别提取出来，进行运算，最后再通过位运算合并起来。

下面是一个ArgbEvaluator的例子（实现view的背景颜色渐变）：
```
ObjectAnimator colorAnim = ObjectAnimator.ofInt(tv_argb, "backgroundColor", 0xFFFF8080, 0xFF8080FF);
        colorAnim.setDuration(3000);
        colorAnim.setEvaluator(new ArgbEvaluator());
        colorAnim.setRepeatCount(ValueAnimator.INFINITE);
        colorAnim.setRepeatMode(ValueAnimator.REVERSE);
        colorAnim.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator animation) {
                tv_argb.setText(Integer.toHexString((Integer) animation.getAnimatedValue()));
            }
        });
        colorAnim.start();
```
TypeEvaluator:这个接口可以用来自定义Evaluator。如果你需要操控的动画属性不是int,float,color类型，你就需要实现TypeEvaluator；另外，如果你有自己的想法，不想使用系统提供的Evaluator，也可以实现TypeEvaluator,下面是一个例子：
```
public class FloatEvaluator implements TypeEvaluator {

    public Object evaluate(float fraction, Object startValue, Object endValue) {
        float startFloat = ((Number) startValue).floatValue();
        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);
    }
}
```

###2.4 Interpolator

Interpolator可以指定属性的value以怎样的函数进行变化，最常见的Interpolator就是LinearInterpolator,它使value一直匀速变化。你可实现value进行加速减速运动，系统为我们提供好了一系列的Interpolator:

* AccelerateInterpolator　　　　　     加速，开始时慢中间加速
* DecelerateInterpolator　　　 　　   减速，开始时快然后减速
* AccelerateDecelerateInterolator　   先加速后减速，开始结束时慢，中间加速
* AnticipateInterpolator　　　　　　  反向 ，先向相反方向改变一段再加速播放
* AnticipateOvershootInterpolator　   反向加回弹，先向相反方向改变，再加速播放，会超出目的值然后缓慢移动至目的值
* BounceInterpolator　　　　　　　  跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100
* CycleIinterpolator　　　　　　　　 循环，动画循环一定次数，值的改变为一正弦函数：Math.sin(2 * mCycles * Math.PI * input)
* LinearInterpolator　　　　　　　　 线性，线性均匀改变
* OvershottInterpolator　　　　　　  回弹，最后超出目的值然后缓慢改变到目的值
* TimeInterpolator　　　　　　　　   一个接口，允许你自定义interpolator，以上几个都是实现了这个接口


所有Interpolator的基类是TimeInterpolator:
```
/**
 * A time interpolator defines the rate of change of an animation. This allows animations
 * to have non-linear motion, such as acceleration and deceleration.
 */
public interface TimeInterpolator {

    /**
     * Maps a value representing the elapsed fraction of an animation to a value that represents
     * the interpolated fraction. This interpolated value is then multiplied by the change in
     * value of an animation to derive the animated value at the current elapsed animation time.
     *
     * @param input A value between 0 and 1.0 indicating our current point
     *        in the animation where 0 represents the start and 1.0 represents
     *        the end
     * @return The interpolation value. This value can be more than 1.0 for
     *         interpolators which overshoot their targets, or less than 0 for
     *         interpolators that undershoot their targets.
     */
    float getInterpolation(float input);
}
```

`getInterpolation`方法的input参数接口一个[0,1]的值，0代表开始，1代表结束。这个方法返回的fraction值可以<0或>1

**Interpolator和Evaluator 区别：**

**如果把整个动画比作一部电影的话，Interpolator就好比播放速率，是正常播放，还是快进，快退，倍速播放；Evaluator会根据Interpolator告诉他的速率，取到当前需要观看的具体时间点，也就是对应哪一帧画面。**

###2.5 Specifying Keyframes

A Keyframe object consists of a time/value pair that lets you define a specific state at a specific time of an animation. Each keyframe can also have its own interpolator to control the behavior of the animation in the interval between the previous keyframe's time and the time of this keyframe.

KeyFrame 是一对时间/value 键值对，可以定义某1个fraction对应的value
之前介绍ObjectAnimator的时候，
```
ObjectAnimator.ofInt(foo, "x", 1, 50，100);
```
看源码的话，其实也是KeyFrame实现的：

| fraction |    0 | 0.5  |  1   |
| :------- | ---: | :--: | :--: |
| value    |    1 |  50  | 100  |

如果是4个参数的话，

```
ObjectAnimator.ofInt(foo, "x", 1, 30，60，100);
```
| fraction |    0 | 0.33 | 0.66 |  1   |
| :------- | ---: | :--: | :--: | :--: |
| value    |    1 |  30  |  60  | 100  |

下面是keyframes构造ObjectAnimator的例子：
```
Keyframe kf0 = Keyframe.ofFloat(0f, 0f);
Keyframe kf1 = Keyframe.ofFloat(.5f, 360f);
Keyframe kf2 = Keyframe.ofFloat(1f, 0f);
PropertyValuesHolder pvhRotation =PropertyValuesHolder.ofKeyframe("rotation", kf0, kf1, kf2);
ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(target, pvhRotation)
rotationAnim.setDuration(5000ms);
rotationAnim.start();
```

##3.Property Animation和View Animation 区别

- View Animation只能操作view，非view对象不能使用。
- View Animation能设置的属性也极其有限，它能设置缩放平移旋转，但是像background这样的属性，却无能为力。
- 另外一个广为人知的缺点，就是它只能控制view绘制的位置，但是view本身的位置还在原处（即使你设置了fillafter为true,view的点击事件还在原来的位置）。如果你想更新view的位置，只能在动画完成之后，setLayoutParams....这就很尴尬了~
- Property Animation就强大多了，它能设置view和非view对象的属性，它还能设置view的background和x,y等属性，只要有set和get方法的属性都可以。

#Android 属性动画解析（2）

属性动画的简单实用是这样的：
```
ObjectAnimator anim = ObjectAnimator.ofFloat(view, "alpha", 0f, 1f);
anim.setDuration(1000);
anim.start();
```

##1. ObjectAnimator.of*

ObjectAnimator的ofFloat方法实现是这样的：
```
public static ObjectAnimator ofFloat(Object target, String propertyName, float... values) {
        ObjectAnimator anim = new ObjectAnimator(target, propertyName);
        anim.setFloatValues(values);
        return anim;
    }
```

这里分为两步
1）ObjectAnimator实例化
2） setValues

###1.1 ObjectAnimator构造方法

```
 private ObjectAnimator(Object target, String propertyName) {
        setTarget(target);
        setPropertyName(propertyName);
    }

    /**
     * Private utility constructor that initializes the target object and property being animated.
     *
     * @param target The object whose property is to be animated.
     * @param property The property being animated.
     */
    private <T> ObjectAnimator(T target, Property<T, ?> property) {
        setTarget(target);
        setProperty(property);
    }
```
构造方法中，
1. setTarget会把需要进行动画的target保存到WeakReference里，主要是为了内存泄漏
```
 /**
     * Sets the target object whose property will be animated by this animation
     *
     * @param target The object being animated
     */
    @Override
    public void setTarget(@Nullable Object target) {
        final Object oldTarget = getTarget();
        if (oldTarget != target) {
            mTarget = target == null ? null : new WeakReference<Object>(target);
            // New target should cause re-initialization prior to starting
            mInitialized = false;
        }
    }
```
2. setProperty方法，会把进行动画的属性存放到hashmap里，这个变量在ObjectAnimator的父类ValueAnimator里：
```

  /**
     * Sets the property that will be animated. Property objects will take precedence over
     * properties specified by the {@link #setPropertyName(String)} method. Animations should
     * be set up to use one or the other, not both.
     *
     * @param property The property being animated. Should not be null.
     */
    public void setProperty(@NonNull Property property) {
        // mValues could be null if this is being constructed piecemeal. Just record the
        // propertyName to be used later when setValues() is called if so.
        if (mValues != null) {
            PropertyValuesHolder valuesHolder = mValues[0];
            String oldName = valuesHolder.getPropertyName();
            valuesHolder.setProperty(property);
            mValuesMap.remove(oldName);
            mValuesMap.put(mPropertyName, valuesHolder);
        }
        if (mProperty != null) {
            mPropertyName = property.getName();
        }
        mProperty = property;
        // New property/values/target should cause re-initialization prior to starting
        mInitialized = false;
    }

  
```
###1.2 set*Values（）

ObjectAnimator提供了三个方法：setIntValues,setFloatValues,setObjectValues，实现是一样的，这里以setFloatValues为例子看一下:（ObjectAnimator.java）
```
@Override
    public void setFloatValues(float... values) {
        if (mValues == null || mValues.length == 0) {
            // No values yet - this animator is being constructed piecemeal. Init the values with
            // whatever the current propertyName is
            if (mProperty != null) {
                setValues(PropertyValuesHolder.ofFloat(mProperty, values));
            } else {
                setValues(PropertyValuesHolder.ofFloat(mPropertyName, values));
            }
        } else {
            super.setFloatValues(values);
        }
    }
```
mValues用于存放需要操作的属性，这时候，mValues肯定为null或者length==0;mProperty在前面setTarget()方法的时候，已经赋了值，所以会走setValues（）方法，

####1.2.1 PropertyValuesHolder.of*

我们需要先看一下参数里values的创建过程：（PropertyValueHolder.java）

```
   /**
     * Constructs and returns a PropertyValuesHolder with a given property and
     * set of float values.
     * @param property The property being animated. Should not be null.
     * @param values The values that the property will animate between.
     * @return PropertyValuesHolder The constructed PropertyValuesHolder object.
     */
    public static PropertyValuesHolder ofFloat(Property<?, Float> property, float... values) {
        return new FloatPropertyValuesHolder(property, values);
    }
```

FloatPropertyValuesHolder是PropertyValuesHolder的一个内部实现类，用于存放float类型的关键帧，看一下它的构造方法：
```
 public FloatPropertyValuesHolder(String propertyName, float... values) {
            super(propertyName);
            setFloatValues(values);
        }
 @Override
   public void setFloatValues(float... values) {
            super.setFloatValues(values);
            mFloatKeyframes = (Keyframes.FloatKeyframes) mKeyframes;
    }       
```
构造方法中，会调用`setFloatValues`,这个方法内部调用了super的实现，这里看一下` super.setFloatValues(values);`    （PropertyValueHolder.java）
```
   /**
     * Set the animated values for this object to this set of floats.
     * If there is only one value, it is assumed to be the end value of an animation,
     * and an initial value will be derived, if possible, by calling a getter function
     * on the object. Also, if any value is null, the value will be filled in when the animation
     * starts in the same way. This mechanism of automatically getting null values only works
     * if the PropertyValuesHolder object is used in conjunction
     * {@link ObjectAnimator}, and with a getter function
     * derived automatically from <code>propertyName</code>, since otherwise PropertyValuesHolder has
     * no way of determining what the value should be.
     *
     * @param values One or more values that the animation will animate between.
     */
    public void setFloatValues(float... values) {
        mValueType = float.class;
        mKeyframes = KeyframeSet.ofFloat(values);
    }
```
这里会把属性所设置的value存放到keyFrames中，看一下KeyframeSet.ofFloat方法：
```
    public static KeyframeSet ofFloat(float... values) {
        boolean badValue = false;
        int numKeyframes = values.length;
        FloatKeyframe keyframes[] = new FloatKeyframe[Math.max(numKeyframes,2)];
        if (numKeyframes == 1) {
            keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f);
            keyframes[1] = (FloatKeyframe) Keyframe.ofFloat(1f, values[0]);
            if (Float.isNaN(values[0])) {
                badValue = true;
            }
        } else {
            keyframes[0] = (FloatKeyframe) Keyframe.ofFloat(0f, values[0]);
            for (int i = 1; i < numKeyframes; ++i) {
                keyframes[i] =
                        (FloatKeyframe) Keyframe.ofFloat((float) i / (numKeyframes - 1), values[i]);
                if (Float.isNaN(values[i])) {
                    badValue = true;
                }
            }
        }
        if (badValue) {
            Log.w("Animator", "Bad value (NaN) in float animator");
        }
        return new FloatKeyframeSet(keyframes);
    }
```
这里会通过 Keyframe.ofFloat（）方法，我们设置value值都赋给keyframes数组，
KeyFrame是一组键值对，key：fraction,value:我们传入的value

看一下Keyframe.ofFloat的实现：

```
 public static Keyframe ofFloat(float fraction, float value) {
        return new FloatKeyframe(fraction, value);
    }

FloatKeyframe(float fraction, float value) {
            mFraction = fraction;
            mValue = value;
            mValueType = float.class;
            mHasValue = true;
        }
```

像我们之前设置的例子:
```
ObjectAnimator anim = ObjectAnimator.ofFloat(view, "alpha", 0f, 1f);
```
会生成两个keyframe,
keyframe[0]={fraction:0,value:0}
keyframe[1]={fraction:1,value:1}

上面代码的13到15行，会把所有的value值转换成keyframe,
如果我们传入的是值是4个 ：0f,0.2f,0.8f,1f,那生成的keyframe是这样的：
keyframe[0]={fraction:0,value:0}
keyframe[1]={fraction:0.33,value:0.2}
keyframe[2]={fraction:0.66,value:0.8}
keyframe[3]={fraction:1,value:1}

ObjectAnimator有很多构造方式，不管你使用哪种，最终都是转换成了keyframe，所以下面的几种构造方式效果是一样的：
1)
```
 ObjectAnimator.ofFloat(view, "alpha", 0f, 0.2f,0.8f, 1f);
```
 2) 
```
 PropertyValuesHolder pvh1=PropertyValuesHolder.ofFloat("alpha", 0f, 0.2f,0.8f,1f);
ObjectAnimator.ofPropertyValuesHolder(view,pvh1);
```
3)
```                 
PropertyValuesHolder pvh2=PropertyValuesHolder.                        
 ofKeyframe("alpha",Keyframe.ofFloat(0f,0f),Keyframe.ofFloat(0.33f,0.2f),Keyframe.ofFloat(0.66f,0.8f), Keyframe.ofFloat(1f,1f));         ObjectAnimator.ofPropertyValuesHolder(view,pvh2);
```
另外，Keyframe是可以设置Interpolator的
```

    /**
     * Sets the optional interpolator for this Keyframe. A value of <code>null</code> indicates
     * that there is no interpolation, which is the same as linear interpolation.
     *
     * @return The optional interpolator for this Keyframe.
     */
    public void setInterpolator(TimeInterpolator interpolator) {
        mInterpolator = interpolator;
    }
```


####1.2.2 setValues
（ValueAnimator.java）
```
/**
     * Sets the values, per property, being animated between. This function is called internally
     * by the constructors of ValueAnimator that take a list of values. But a ValueAnimator can
     * be constructed without values and this method can be called to set the values manually
     * instead.
     *
     * @param values The set of values, per property, being animated between.
     */
    public void setValues(PropertyValuesHolder... values) {
        int numValues = values.length;
        mValues = values;
        mValuesMap = new HashMap<String, PropertyValuesHolder>(numValues);
        for (int i = 0; i < numValues; ++i) {
            PropertyValuesHolder valuesHolder = values[i];
            mValuesMap.put(valuesHolder.getPropertyName(), valuesHolder);
        }
        // New property/values/target should cause re-initialization prior to starting
        mInitialized = false;
    }
```
这里把上一步生成的PropertyValueHolder存放到mValues变量中，mValuesMap里，key为property属性，value为PropertyValueHolder。

```
 */
public class PropertyValuesHolder implements Cloneable {

  
    String mPropertyName;

    /**
     * @hide
     */
    protected Property mProperty;

    /**
     * The set of keyframes (time/value pairs) that define this animation.
     */
    KeyframeSet mKeyframeSet = null;
    
}

```

PropertyValueHolder类中，有mPropertyName和mKeyframeSet，存放的是需要进行动画的属性及他的一组变化值

```
class KeyframeSet {

    int mNumKeyframes;

    Keyframe mFirstKeyframe;
    Keyframe mLastKeyframe;
    TimeInterpolator mInterpolator; // only used in the 2-keyframe case
    ArrayList<Keyframe> mKeyframes; // only used when there are not 2 keyframes
    TypeEvaluator mEvaluator;
}
```

KeyframeSet中有mKeyframes数组，存放某些关键帧的数值，这些值以keyframe（fraction-value）的形式存在数组里。

到这里，构造方法就准备结束了。

##2.ObjectAnimator.start()

 (ObjectAnimator.java)

```
  @Override
    public void start() { 
        // See if any of the current active/pending animators need to be canceled
        //省略这部分代码
        super.start();
    }
```
这里主要看一下父类ValueAnimator的start()方法：(ValueAnimator.java)
```
 @Override
    public void start() {
        start(false);
    }
```
(ValueAnimator.java)


1）这个方法接收一个boolean类型的变量控制动画是否是reverse的，默认是false,如果调用了reverse（）方法，则会是true. 
2）动画会在start()方法调用的线程被启动，
```

    /**
     * Start the animation playing. This version of start() takes a boolean flag that indicates
     * whether the animation should play in reverse. The flag is usually false, but may be set
     * to true if called from the reverse() method.
     *
     * <p>The animation started by calling this method will be run on the thread that called
     * this method. This thread should have a Looper on it (a runtime exception will be thrown if
     * this is not the case). Also, if the animation will animate
     * properties of objects in the view hierarchy, then the calling thread should be the UI
     * thread for that view hierarchy.</p>
     *
     * @param playBackwards Whether the ValueAnimator should start playing in reverse.
     */
    private void start(boolean playBackwards) {
        if (Looper.myLooper() == null) {
            throw new AndroidRuntimeException("Animators may only be run on Looper threads");
        }
        mReversing = playBackwards;
        mPlayingBackwards = playBackwards;
        
        //省略部分代码
        AnimationHandler animationHandler = getOrCreateAnimationHandler();
        animationHandler.mPendingAnimations.add(this);
        if (mStartDelay == 0) {
            // This sets the initial value of the animation, prior to actually starting it running
            if (prevPlayingState != SEEKED) {
                setCurrentPlayTime(0);
            }
            mPlayingState = STOPPED;
            mRunning = true;
            notifyStartListeners();
        }
        animationHandler.start();
    }
```

这里看到设置了一些状态标识，mPlayingStated代表当前动画的状态(STOPPED, RUNNING, SEEKED)，

```
/**
 * Values used with internal variable mPlayingState to indicate the current state of an
 * animation.
 */
static final int STOPPED    = 0; // Not yet playing
static final int RUNNING    = 1; // Playing normally
static final int SEEKED     = 2; // Seeked to some time value
```

AnimationHandler 是一个实现了Runnable接口的ValueAnimator内部类,这里注意  24行，`animationHandler.mPendingAnimations.add(this);`,将要执行的动画被存放到了mPendingAnimations中。

**这里重要的有两步，

1. setCurrentPlayTime（0）
2.  animationHandler.start();



### 2.1 setCurrentPlayTime(0)

```
    public void setCurrentPlayTime(long playTime) {
        initAnimation();
        long currentTime = AnimationUtils.currentAnimationTimeMillis();
        if (mPlayingState != RUNNING) {
            mSeekTime = playTime;
            mPlayingState = SEEKED;
        }
        mStartTime = currentTime - playTime;
        doAnimationFrame(currentTime);
    }
```

看一下initAnimation（）

```
void initAnimation() {
        if (!mInitialized) {
            int numValues = mValues.length;
            for (int i = 0; i < numValues; ++i) {
                mValues[i].init();
            }
            mInitialized = true;
        }
    }
```

我们知道mValues其实是PropertyValueHolder的实例,这是看下它的init方法：

```
  /**
     * Internal function, called by ValueAnimator, to set up the TypeEvaluator that will be used
     * to calculate animated values.
     */
    void init() {
        if (mEvaluator == null) {
            // We already handle int and float automatically, but not their Object
            // equivalents
            mEvaluator = (mValueType == Integer.class) ? sIntEvaluator :
                    (mValueType == Float.class) ? sFloatEvaluator :
                    null;
        }
        if (mEvaluator != null) {
            // KeyframeSet knows how to evaluate the common types - only give it a custom
            // evaluator if one has been set on this class
            mKeyframeSet.setEvaluator(mEvaluator);
        }
    }
```

这里会根据属性的某些类型（int,float)自动创建mEvaluator),否则默认为null

### 2.2 animationHandler.start()

```
/**
 * Start animating on the next frame.
 */
public void start() {
    scheduleAnimation();
}

 private void scheduleAnimation() {
            if (!mAnimationScheduled) {
                mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, this, null);
                mAnimationScheduled = true;
            }
        }
```

这里mChoreographer这个类来控制同步处理输入(Input)、动画(Animation)、绘制(Draw)三个UI操作。其实UI显示的时候每一帧要完成的事情只有这三种。Choreographer接收显示系统的时间脉冲(垂直同步信号-VSync信号)，在下一个frame渲染时控制执行这些操作。详细的不再介绍。这里的回调每16ms执行一次，

```
  // Called by the Choreographer.
        @Override
        public void run() {
            mAnimationScheduled = false;
            doAnimationFrame(mChoreographer.getFrameTime());
        }
```

执行animationHandler的doAnimationFrame方法：

```
        private void doAnimationFrame(long frameTime) {
            // mPendingAnimations holds any animations that have requested to be started
            // We're going to clear mPendingAnimations, but starting animation may
            // cause more to be added to the pending list (for example, if one animation
            // starting triggers another starting). So we loop until mPendingAnimations
            // is empty.
            while (mPendingAnimations.size() > 0) {
                ArrayList<ValueAnimator> pendingCopy =
                        (ArrayList<ValueAnimator>) mPendingAnimations.clone();
                mPendingAnimations.clear();
                int count = pendingCopy.size();
                for (int i = 0; i < count; ++i) {
                    ValueAnimator anim = pendingCopy.get(i);
                    // If the animation has a startDelay, place it on the delayed list
                    if (anim.mStartDelay == 0) {
                        anim.startAnimation(this);
                    } else {
                        mDelayedAnims.add(anim);
                    }
                }
            }
            // Next, process animations currently sitting on the delayed queue, adding
            // them to the active animations if they are ready
            int numDelayedAnims = mDelayedAnims.size();
            for (int i = 0; i < numDelayedAnims; ++i) {
                ValueAnimator anim = mDelayedAnims.get(i);
                if (anim.delayedAnimationFrame(frameTime)) {
                    mReadyAnims.add(anim);
                }
            }
            int numReadyAnims = mReadyAnims.size();
            if (numReadyAnims > 0) {
                for (int i = 0; i < numReadyAnims; ++i) {
                    ValueAnimator anim = mReadyAnims.get(i);
                    anim.startAnimation(this);
                    anim.mRunning = true;
                    mDelayedAnims.remove(anim);
                }
                mReadyAnims.clear();
            }

            // Now process all active animations. The return value from animationFrame()
            // tells the handler whether it should now be ended
            int numAnims = mAnimations.size();
            for (int i = 0; i < numAnims; ++i) {
                mTmpAnimations.add(mAnimations.get(i));
            }
            for (int i = 0; i < numAnims; ++i) {
                ValueAnimator anim = mTmpAnimations.get(i);
                if (mAnimations.contains(anim) && anim.doAnimationFrame(frameTime)) {
                    mEndingAnims.add(anim);
                }
            }
            mTmpAnimations.clear();
            if (mEndingAnims.size() > 0) {
                for (int i = 0; i < mEndingAnims.size(); ++i) {
                    mEndingAnims.get(i).endAnimation(this);
                }
                mEndingAnims.clear();
            }

            // If there are still active or delayed animations, schedule a future call to
            // onAnimate to process the next frame of the animations.
            if (!mAnimations.isEmpty() || !mDelayedAnims.isEmpty()) {
                scheduleAnimation();
            }
        }
```

1.遍历pending list动画，如果delay为0 则调用start，不为0，加入delay list；

2.遍历delay list， 根据frametime计算是继续delay还是ready可以播放，若是ready，则加入到ready list中；

3 遍历ready list，调用start ；

4，遍历所有animation，根据frametime计算动画是否要结束，如果可以结束，则加入到ending list中；

5，遍历ending list， 调用end；

6， 如果有列表中仍然有动画，则继续scheduleAnimation；

我们上边start的时候，说过，将要执行的动画，被加入到mPendingAnimations中，

```
 for (int i = 0; i < count; ++i) {
                    ValueAnimator anim = pendingCopy.get(i);
                    // If the animation has a startDelay, place it on the delayed list
                    if (anim.mStartDelay == 0) {
                        anim.startAnimation(this);
                    } else {
                        mDelayedAnims.add(anim);
                    }
                }
```

调用了startAnimation

```
 /**
     * Called internally to start an animation by adding it to the active animations list. Must be
     * called on the UI thread.
     */
    private void startAnimation(AnimationHandler handler) {
        if (Trace.isTagEnabled(Trace.TRACE_TAG_VIEW)) {
            Trace.asyncTraceBegin(Trace.TRACE_TAG_VIEW, getNameForTrace(),
                    System.identityHashCode(this));
        }
        initAnimation();
        handler.mAnimations.add(this);
        if (mStartDelay > 0 && mListeners != null) {
            // Listeners were already notified in start() if startDelay is 0; this is
            // just for delayed animations
            notifyStartListeners();
        }
    }
```

这里注意11行，把动画又加入到mAnimations集合中，`notifyStartListeners`会通知监听，动画启动了：

```
  private void notifyStartListeners() {
        if (mListeners != null && !mStartListenersCalled) {
            ArrayList<AnimatorListener> tmpListeners =
                    (ArrayList<AnimatorListener>) mListeners.clone();
            int numListeners = tmpListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                tmpListeners.get(i).onAnimationStart(this);
            }
        }
        mStartListenersCalled = true;
    }

```

现在回到doAnimationFrame方法：

```
   int numAnims = mAnimations.size();
            for (int i = 0; i < numAnims; ++i) {
                mTmpAnimations.add(mAnimations.get(i));
            }
            for (int i = 0; i < numAnims; ++i) {
                ValueAnimator anim = mTmpAnimations.get(i);
                if (mAnimations.contains(anim) && anim.doAnimationFrame(frameTime)) {
                    mEndingAnims.add(anim);
                }
            }
```

因为执行的动画已经加入到了mAnimations中，这里numAnims不为0，最后会调用到ValueAnimator的`doAnimationFrame`方法：

```
    /**
     * Processes a frame of the animation, adjusting the start time if needed.
     *
     * @param frameTime The frame time.
     * @return true if the animation has ended.
     */
    final boolean doAnimationFrame(long frameTime) {
        if (mPlayingState == STOPPED) {
            mPlayingState = RUNNING;
            if (mSeekTime < 0) {
                mStartTime = frameTime;
            } else {
                mStartTime = frameTime - mSeekTime;
                // Now that we're playing, reset the seek time
                mSeekTime = -1;
            }
        }
        if (mPaused) {
            if (mPauseTime < 0) {
                mPauseTime = frameTime;
            }
            return false;
        } else if (mResumed) {
            mResumed = false;
            if (mPauseTime > 0) {
                // Offset by the duration that the animation was paused
                mStartTime += (frameTime - mPauseTime);
            }
        }
        // The frame time might be before the start time during the first frame of
        // an animation.  The "current time" must always be on or after the start
        // time to avoid animating frames at negative time intervals.  In practice, this
        // is very rare and only happens when seeking backwards.
        final long currentTime = Math.max(frameTime, mStartTime);
        return animationFrame(currentTime);
    }
```

真正的逻辑在`animationFrame(currentTime)`中：

```
  boolean animationFrame(long currentTime) {
        boolean done = false;
        switch (mPlayingState) {
        case RUNNING:
        case SEEKED:
            float fraction = mDuration > 0 ? (float)(currentTime - mStartTime) / mDuration : 1f;
            if (fraction >= 1f) {
                if (mCurrentIteration < mRepeatCount || mRepeatCount == INFINITE) {
                    // Time to repeat
                    if (mListeners != null) {
                        int numListeners = mListeners.size();
                        for (int i = 0; i < numListeners; ++i) {
                            mListeners.get(i).onAnimationRepeat(this);
                        }
                    }
                    if (mRepeatMode == REVERSE) {
                        mPlayingBackwards = !mPlayingBackwards;
                    }
                    mCurrentIteration += (int)fraction;
                    fraction = fraction % 1f;
                    mStartTime += mDuration;
                } else {
                    done = true;
                    fraction = Math.min(fraction, 1.0f);
                }
            }
            if (mPlayingBackwards) {
                fraction = 1f - fraction;
            }
            animateValue(fraction);
            break;
        }

        return done;
    }
    
...
    void animateValue(float fraction) {
        fraction = mInterpolator.getInterpolation(fraction);
        mCurrentFraction = fraction;
        int numValues = mValues.length;
        for (int i = 0; i < numValues; ++i) {
            mValues[i].calculateValue(fraction);
        }
        if (mUpdateListeners != null) {
            int numListeners = mUpdateListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                mUpdateListeners.get(i).onAnimationUpdate(this);
            }
        }
    }
```

```
   float fraction = mDuration > 0 ? (float)(currentTime - mStartTime) / mDuration : 1f;
```

fraction相当于进度条的位置，

```
fraction = mInterpolator.getInterpolation(fraction);
```

根据插值器，得到真在的进度

```
 mValues[i].calculateValue(fraction);
```

```
/**
 * Function used to calculate the value according to the evaluator set up for
 * this PropertyValuesHolder object. This function is called by ValueAnimator.animateValue().
 *
 * @param fraction The elapsed, interpolated fraction of the animation.
 */
void calculateValue(float fraction) {
    mAnimatedValue = mKeyframeSet.getValue(fraction);
}
```

```
    public Object getValue(float fraction) {

        // Special-case optimization for the common case of only two keyframes
        if (mNumKeyframes == 2) {
            if (mInterpolator != null) {
                fraction = mInterpolator.getInterpolation(fraction);
            }
            return mEvaluator.evaluate(fraction, mFirstKeyframe.getValue(),
                    mLastKeyframe.getValue());
        }
        if (fraction <= 0f) {
            final Keyframe nextKeyframe = mKeyframes.get(1);
            final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
            if (interpolator != null) {
                fraction = interpolator.getInterpolation(fraction);
            }
            final float prevFraction = mFirstKeyframe.getFraction();
            float intervalFraction = (fraction - prevFraction) /
                (nextKeyframe.getFraction() - prevFraction);
            return mEvaluator.evaluate(intervalFraction, mFirstKeyframe.getValue(),
                    nextKeyframe.getValue());
        } else if (fraction >= 1f) {
            final Keyframe prevKeyframe = mKeyframes.get(mNumKeyframes - 2);
            final TimeInterpolator interpolator = mLastKeyframe.getInterpolator();
            if (interpolator != null) {
                fraction = interpolator.getInterpolation(fraction);
            }
            final float prevFraction = prevKeyframe.getFraction();
            float intervalFraction = (fraction - prevFraction) /
                (mLastKeyframe.getFraction() - prevFraction);
            return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(),
                    mLastKeyframe.getValue());
        }
        Keyframe prevKeyframe = mFirstKeyframe;
        for (int i = 1; i < mNumKeyframes; ++i) {
            Keyframe nextKeyframe = mKeyframes.get(i);
            if (fraction < nextKeyframe.getFraction()) {
                final TimeInterpolator interpolator = nextKeyframe.getInterpolator();
                if (interpolator != null) {
                    fraction = interpolator.getInterpolation(fraction);
                }
                final float prevFraction = prevKeyframe.getFraction();
                float intervalFraction = (fraction - prevFraction) /
                    (nextKeyframe.getFraction() - prevFraction);
                return mEvaluator.evaluate(intervalFraction, prevKeyframe.getValue(),
                        nextKeyframe.getValue());
            }
            prevKeyframe = nextKeyframe;
        }
        // shouldn't reach here
        return mLastKeyframe.getValue();
    }
```

根据evaluator，返回当前帧的值。

这里可能会有疑问，这里只取到了值，并没有设置到view的属性上呀？

因为现在的逻辑都在valueAnimator中，这个类是跟view属性不关的，

```
void animateValue(float fraction) {
        fraction = mInterpolator.getInterpolation(fraction);
        mCurrentFraction = fraction;
        int numValues = mValues.length;
        for (int i = 0; i < numValues; ++i) {
            mValues[i].calculateValue(fraction);
        }
        if (mUpdateListeners != null) {
            int numListeners = mUpdateListeners.size();
            for (int i = 0; i < numListeners; ++i) {
                mUpdateListeners.get(i).onAnimationUpdate(this);
            }
        }
    }
```

valueAnimator最终方法执行到这里，我们可以去看一下ObjectAnimator类，发现他重写了该方法：

```
   @Override
    void animateValue(float fraction) {
        super.animateValue(fraction);
        int numValues = mValues.length;
        for (int i = 0; i < numValues; ++i) {
            mValues[i].setAnimatedValue(mTarget);
        }
    }
```

果然，关键点在   mValues[i].setAnimatedValue(mTarget);中：

```

    /**
     * Internal function to set the value on the target object, using the setter set up
     * earlier on this PropertyValuesHolder object. This function is called by ObjectAnimator
     * to handle turning the value calculated by ValueAnimator into a value set on the object
     * according to the name of the property.
     * @param target The target object on which the value is set
     */
    void setAnimatedValue(Object target) {
        if (mProperty != null) {
            mProperty.set(target, getAnimatedValue());
        }
        if (mSetter != null) {
            try {
                mTmpValueArray[0] = getAnimatedValue();
                mSetter.invoke(target, mTmpValueArray);
            } catch (InvocationTargetException e) {
                Log.e("PropertyValuesHolder", e.toString());
            } catch (IllegalAccessException e) {
                Log.e("PropertyValuesHolder", e.toString());
            }
        }
    }
```

这里的target就是被执行动画的view，mProperty是Property类的实例，我们传入字符串的话，这里为空，那肯定进入了下边的判断条件，那setter什么时候设置的呢？

ObjectAnimator调用start方法的时候，会先调用setCurrentPlayTime(0)

```
  public void setCurrentPlayTime(long playTime) {
        initAnimation();
        long currentTime = AnimationUtils.currentAnimationTimeMillis();
        if (mPlayingState != RUNNING) {
            mSeekTime = playTime;
            mPlayingState = SEEKED;
        }
        mStartTime = currentTime - playTime;
        doAnimationFrame(currentTime);
    }

  void initAnimation() {
        if (!mInitialized) {
            int numValues = mValues.length;
            for (int i = 0; i < numValues; ++i) {
                mValues[i].init();
            }
            mInitialized = true;
        }
    }
```

这里调用了initAnimation，进行了初始化，其实ObjectAnimator重写了该方法：

```
 */
@Override
void initAnimation() {
    if (!mInitialized) {
        // mValueType may change due to setter/getter setup; do this before calling super.init(),
        // which uses mValueType to set up the default type evaluator.
        int numValues = mValues.length;
        for (int i = 0; i < numValues; ++i) {
            mValues[i].setupSetterAndGetter(mTarget);
        }
        super.initAnimation();
    }
}
```

```
mValues[i].setupSetterAndGetter(mTarget);
```

这个方法里，就用了反射取到了set方法，这里省略部分逻辑：

```
 private Method getPropertyFunction(Class targetClass, String prefix, Class valueType) {
        // TODO: faster implementation...
        Method returnVal = null;
        String methodName = getMethodName(prefix, mPropertyName);
        Class args[] = null;
        if (valueType == null) {
            try {
                returnVal = targetClass.getMethod(methodName, args);
            } catch (NoSuchMethodException e) {
                // Swallow the error, log it later
            }
        } else {
            args = new Class[1];
            Class typeVariants[];
            if (mValueType.equals(Float.class)) {
                typeVariants = FLOAT_VARIANTS;
            } else if (mValueType.equals(Integer.class)) {
                typeVariants = INTEGER_VARIANTS;
            } else if (mValueType.equals(Double.class)) {
                typeVariants = DOUBLE_VARIANTS;
            } else {
                typeVariants = new Class[1];
                typeVariants[0] = mValueType;
            }
            for (Class typeVariant : typeVariants) {
                args[0] = typeVariant;
                try {
                    returnVal = targetClass.getMethod(methodName, args);
                    // change the value type to suit
                    mValueType = typeVariant;
                    return returnVal;
                } catch (NoSuchMethodException e) {
                    // Swallow the error and keep trying other variants
                }
            }
            // If we got here, then no appropriate function was found
        }


```

我们在回到上面的animateValue中：

```
 if (mSetter != null) {
            try {
                mTmpValueArray[0] = getAnimatedValue();
                mSetter.invoke(target, mTmpValueArray);
            } catch (InvocationTargetException e) {
                Log.e("PropertyValuesHolder", e.toString());
            } catch (IllegalAccessException e) {
                Log.e("PropertyValuesHolder", e.toString());
            }
        }
```

这里就用反射把当前的值更新到view中。这样，一次的逻辑就完成了。我们知道这里用了Choreographer，每16ms执行一次，

```
// Called by the Choreographer.
@Override
public void run() {
    mAnimationScheduled = false;
    doAnimationFrame(mChoreographer.getFrameTime());
}

private void scheduleAnimation() {
    if (!mAnimationScheduled) {
        mChoreographer.postCallback(Choreographer.CALLBACK_ANIMATION, this, null);
        mAnimationScheduled = true;
    }
}
```

16ms run-->执行handler.doAnimationFrame-->valueObjector.doAnimationFrame-->animationFrame-->animatevalue-->16ms run.这样递归直至动画结束。